# 04. Props 와 State

Props는 컴포넌트 외부에서 컴포넌트에게 주는 데이터이며

State는 컴포넌트 내부에서 변경 할 수 있는 데이터입니다.(즉, 컴포넌트 상태에 따라 값이 변경 될 수 있습니다.)

\*둘다 변경이 발생하면, 랜더가 다시 일어날 수 있습니다.(랜더 함수 호출)

<img width="811" src="https://user-images.githubusercontent.com/32887635/197555870-c93aeb4d-95bd-4f0a-be77-7ae7d69ecd33.png">

## Props

### function Component의 Props

: Component(props), return, props.message

```javascript
// function은 매개변수 형태로 props를 받음
function Component(props) {
  return (
    <div>
      <h1>{props.message} 이것은 함수로 만든 컴포넌트 입니다.</h1>
    </div>
  );
}

ReactDOM.render(<Component message="Hi" />, document.querySelector("#root"));
```

### Class Component의 Props

: extends React.Component, render(), this.props.message

```javascript
//class는 매개변수 형태 아님, this 사용
//class는 extend, render()이라는 구문이 추가됨
class Component extends React.Component {
  render() {
    return (
      <div>
        <h1>{this.props.message} 이것은 클래스로 만든 컴포넌트 입니다.</h1>
      </div>
    );
  }

ReactDOM.render(<Component message="Hi" />, document.querySelector("#root"));
}
```

### Default Props

1. funtion, class 모두 사용 가능한 방법

```javascript
Component.defaultProps = {
  message: "기본값",
};
```

2. class만 사용 가능한 방법

```javascript
// 2. 클래스 내부에 해당 키워드를 선언
static defaultProps = {
    message: "기본값" ,
};
```

> https://github.com/JEONGBOYEON/study-react/blob/main/projects/props.html

---

## State

state는 컴포넌트 내부에서 바뀔 수 있는 값을 의미합니다. props는 컴포넌트가 사용되는 과정에서 부모 컴포넌트가 설정하는 값이며, 컴포넌트 자신은 해당 props를 읽기 전용으로만 사용할 수 있습니다. props를 바꾸려면 부모 컴포넌트에서 바꾸어 주어야 합니다.

리액트에는 두 가지 종류의 state가 있습니다. 하나는 클래스형 컴포넌트가 지니고 있는 state이고, 다른 하나는 함수형 컴포넌트에서 useState라는 함수를 통해 사용하는 state입니다.

## Class Component의 State

### 선언 방식 1 : constructor 매서드 사용

가장 먼저 state는 constructor 생성자 메서드 내부에서 초기화 해주는 방식이 있습니다. 이때 반드시 super(props)를 호출해 주어야 합니다.

> super(props): 이 함수가 호출되면 현재 클래스형 컴포넌트가 상속하고 있는 리액트의 Component 클래스가 지닌 생성자 함수를 호출해 줍니다.

그다음에는 this.state 값에 초깃값을 설정해 주었습니다. 컴포넌트의 state는 객체 형식이어야 합니다.

```javascript
constructor(props) {
  super(props);
  // state의 초깃값 설정하기
  this.state = {
      number: 0
    };
  }
```

### 선언 방식 2 : constructor 매서드 사용 x

다음으로는 constructor 생성자 메서드를 사용하지 않고 선언 하는 방식입니다.

```javascript
class Counter extends Component {
  state = {
    number: 0,
    fixedNumber: 0
  };
  render() {
    const { number, fixedNumber } = this.state;
    return (...);
  }
}
```

### 조회와 변경

state의 값은 조회, 변경 해줄수 있습니다.

1. 조회: this.state
2. 변경: this.setState({})

```javascript
import React, { Component } from ‘react‘;

class Counter extends Component {
  constructor(props) {
    super(props);
    // state의 초깃값 설정하기
    this.state = {
      number: 0
    };
  }

  render() {
    const { number } = this.state;
    // 값이 여러개 일 경우
    // const { number, number2 } = this.state;
    return (
      <div>
        <h1>{number}</h1>
      </div>
    );

    componentDidMount(){
        setTimeout(()=>{
            this.setState({count: this.state.count+1});
        },1000);
    }
  }
}

export default Counter;
```

### 동기 처리 해주기 1

state 값을 업데이트할 때는 상태가 **비동기적**으로 업데이트됩니다. 따라서 다음과 같이 this.setState를 두 번 호출하더라도 한번만 호출될 수 있습니다. 이는 this.setState를 사용한다고 해서 state 값이 바로 바뀌지는 않기 때문입니다.

```javascript
onClick={() => {
  // this.setState를 사용하여 state에 새로운 값을 넣을 수 있습니다.
  this.setState({ number: number + 1 });
  this.setState({ number: this.state.number + 1 });
}}
```

이를 해결하기 위해 setState의 인자에 객체 대신 함수를 넘겨줄 수 있습니다. 여기서 prevState는 기존 상태이고, props는 현재 지니고 있는 props를 가리킵니다. 만약 업데이트하는 과정에서 props가 필요하지 않다면 생략해도 됩니다.

```javascript
this.setState((prevState, props) => {
  return {
    // 업데이트하고 싶은 내용
  };
});
```

### 동기 처리 해주기 2

setState를 사용하여 값을 업데이트하고 난 다음에 특정 작업을 하고 싶을 때는 setState의 두 번째 파라미터로 콜백(callback) 함수를 등록하여 작업을 처리할 수 있습니다.

```javascript
<button
  onClick={() => {
    this.setState(
      {
        number: number + 1
      },
      () => {
        console.log(‘방금 setState가 호출되었습니다.’);
      }
    );
  }}
>
  +1
</button>
```
